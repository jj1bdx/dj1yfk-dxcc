#!/usr/bin/env perl

# dxcc - determining the DXCC country of a callsign
# modified by Kenji Rikitake, JJ1BDX.
# See https://github.com/jj1bdx/dj1yfk-dxcc/ for the details.
# (c) 2022 Kenji Rikitake, JJ1BDX
#
# Copyright (C) 2007-2019  Fabian Kurz, DJ1YFK
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

use strict;
use warnings;
use POSIX;
use File::Basename;

# Where the script resides
my $scriptdirname = dirname(__FILE__);

my $version = 'VERSION';
my $credits = "dxcc modified by Kenji Rikitake, JJ1BDX.
See https://github.com/jj1bdx/dj1yfk-dxcc/ for the details.
(c) 2022 Kenji Rikitake, JJ1BDX 

Originally from:
dxcc 20191204 (c) Fabian Kurz, DJ1YFK.  http://fkurz.net/ham/dxcc.html

Determines the ARRL DXCC entity of a ham radio callsign, based on the cty.dat
country file by Jim Reisert, AD1C (http://country-files.com/). 

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.";

my %fullcalls;    # hash of arrays  fullcalls -> dxcc data
my %prefixes;     # hash of arrays  prefixes -> dxcc data
my @dxcc;

my $args = '';

&DxccReadCty();

if ( !$ARGV[0] ) {
    print "$credits

Usage:  dxcc <callsign>\n\n";

    exit;
}
else {
    $args = "@ARGV";
}

{
    my @dxcc = &DxccGetRecord("\U$args");

    print "Callsign: \U$args\n\n";

    print "Main Prefix:    $dxcc[7]\n";
    print "Country Name:   $dxcc[0]\n";
    print "WAZ Zone:       $dxcc[1]\n";
    print "ITU Zone:       $dxcc[2]\n";
    print "Continent:      $dxcc[3]\n";
    print "Latitude:       $dxcc[4]\n";
    print "Longitude:      $dxcc[5]\n";
    print "UTC shift:      $dxcc[6]\n";

    print "\n";
}

###############################################################################
#
# &DxccWpx derives the Prefix following WPX rules from a call.
# The rules can be found at: http://www.cq-amateur-radio.com/wpxrules.html
# e.g. DJ1YFK/TF3  can be counted as both DJ1 or TF3, but this sub does
# not ask for that, always TF3 (= the attached prefix) is returned. If that is
# not want the OP wanted, it can still be modified manually.
#
###############################################################################

sub DxccWpx {
    my $prefix;
    my $a;
    my $b;
    my $c;
    my $call         = $_[0];
    my $lidadditions = "^QRP\$|^LGT\$";
    my $csadditions  = "(^P\$)|(^M{1,2}\$)|(^AM\$)|(^A\$)";

  # First check if the call is in the proper format, A/B/C where A and C
  # are optional (prefix of guest country and P, MM, AM etc) and B is the
  # callsign. Only letters, figures and "/" is accepted, no further check if the
  # callsign "makes sense".

   # Possible formats:
   # JJ1BDX: B = JJ1BDX
   # JJ1BDX/KL7: B = JJ1BDX / C = KL7
   # KL7/JJ1BDX/P : two slashes, easy to determine: A = KL7 / B = JJ1BDX / C = P

    if ( $call =~ /^((\d|[A-Z])+)$/ ) {
        $a = undef;
        $b = $1;
        $c = undef;
    }
    elsif ( $call =~ /^((\d|[A-Z])+)\/((\d|[A-Z])+)$/ ) {
        $a = undef;
        $b = $1;
        $c = $3;
    }
    elsif ( $call =~ /^((\d|[A-Z])+)\/((\d|[A-Z])+)\/((\d|[A-Z])+)$/ ) {
        $a = $1;
        $b = $3;
        $c = $5;
    }
    else {
        return '';
    }

    # Then how to distinguish KL7/JJ1BDX correctly?
    # If the first part is a known prefix, then let the part (in B) be A
    # and let the main callsign (in C) part be B
    # if not: HEURISTIC: if the first part length is smaller than second part,
    # the first part is highly likely to be a prefix

    if ( exists( $prefixes{$b} ) ) {
        $a = $b;
        $b = $c;
        $c = undef;
    }
    elsif ( length($b) < length($c) ) {
        $a = $b;
        $b = $c;
        $c = undef;
    }

    # Remove liddish callsign additions like /QRP and /LGT.
    if ( defined($c) && ( $c =~ /$lidadditions/ ) )
    {    # check if $b is a lid-addition
        $c = undef;
    }

    # Depending on these values we have to determine the prefix.
    # Following cases are possible:
    #
    # 1.    $a and $c undef --> only callsign, subcases
    # 1.1   $b contains a number -> everything from start to number
    # 1.2   $b contains no number -> first two letters plus 0
    # 2.    $a undef, subcases:
    # 2.1   $c is only a number -> $a with changed number
    # 2.2   $c is /P,/M,/MM,/AM -> 1.
    # 2.3   $c is something else and will be interpreted as a Prefix
    # 3.    $a is defined, will be taken as PFX, regardless of $c

    if ( ( not defined($a) ) && ( not defined($c) ) ) {    # Case 1
        if ( $b =~ /\d/ ) {    # Case 1.1, contains number
            $b =~ /(.+\d)[A-Z]*/;    # Prefix is all but the last
            $prefix = $1;            # Letters
        }
        else {                       # Case 1.2, no number
            $prefix = substr( $b, 0, 2 ) . "0";    # first two + 0
        }
    }
    elsif ( ( not defined($a) ) && ( defined($c) ) ) {    # Case 2, CALL/X
        if ( $c =~ /^(\d)$/ ) {                           # Case 2.1, number
            $b =~ /(.+\d)[A-Z]*/;                         # regular Prefix in $1
                # Here we need to find out how many digits there are in the
                # prefix, because for example A45XR/0 is A40. If there are 2
                # numbers, the first is not deleted. If course in exotic cases
                # like N66A/7 -> N7 this brings the wrong result of N67, but I
                # think that's rather irrelevant cos such calls rarely appear
                # and if they do, it's very unlikely for them to have a number
                # attached.   You can still edit it by hand anyway..

            if ( $1 =~ /^([A-Z]\d)\d$/ ) {    # e.g. A45   $c = 0
                $prefix = $1 . $c;            # ->   A40
            }
            else {                            # Otherwise cut all numbers
                $1 =~ /(.*[A-Z])\d+/;         # Prefix w/o number in $1
                $prefix = $1 . $c;
            }    # Add attached number
        }
        elsif ( $c =~ /$csadditions/ ) {
            $b =~ /(.+\d)[A-Z]*/;    # Known attachment -> like Case 1.1
            $prefix = $1;
        }
        elsif ( $c =~ /^\d\d+$/ ) {    # more than 2 numbers -> ignore
            $b =~ /(.+\d)[A-Z]*/;      # see above
            $prefix = $1;
        }
        else {                         # Must be a Prefix!
            if ( $c =~ /\d$/ ) {       # ends in number -> good prefix
                $prefix = $c;
            }
            else {                     # Add Zero at the end
                $prefix = $c . "0";
            }
        }
    }
    elsif ( defined $a ) {    # $a contains the prefix we want
        if ( $a =~ /\d$/ ) {    # ends in number -> good prefix
            $prefix = $a;
        }
        else {                  # add zero if no number
            $prefix = $a . "0";
        }
    }

    # In very rare cases (right now I can only think of KH5K and KH7K and FRxG/T
    # etc), the prefix is wrong, for example KH5K/DJ1YFK would be KH5K0. In this
    # case, the superfluous part will be cropped.
    if ( $prefix =~ /(\w+\d)[A-Z]+\d/ ) {
        $prefix = $1;
    }

    # debug
    # print "wpx prefix: $prefix\n";
    return $prefix;
}    # DxccWpx ends here

##############################################################################
#
# &DxccGetRecord determines the DXCC country of a given callsign
# using the cty.dat country file by
# Jim Reisert, AD1C (http://country-files.com/).
#
# An example entry of the file looks like this:
#
# Portugal:                 14:  37:  EU:   39.50:     8.00:     0.0:  CT:
#    CQ,CR,CS,CT,=CR5FB/LH,=CS2HNI/LH,=CS5E/LH,=CT/DJ5AA/LH,=CT1BWW/LH,=CT1GFK/LH,=CT1GPQ/LGT,
#    =CT7/ON4LO/LH,=CT7/ON7RU/LH;
#
# The first line contains the name of the country, WAZ, ITU zones, continent,
# latitude, longitude, UTC difference and main Prefix, the second line contains
# possible Prefixes and/or whole callsigns that fit for the country, sometimes
# followed by zones in brackets (WAZ in (), ITU in []).
#
# First this sub scans the fullcall list for exact matches, which handles the
# special cases of the callsign.
# Then the callsign (or what appears to be the part determining the DXCC if
# there is a "/" in the callsign) are checked against
# the list of known prefixes, and the best (longest) matching one
# is taken as the result.
#
# This sub checks the callsign against this list and the DXCC in which
# the best match (longest matching characters) appear.
# This is needed because for example
# the CTY file specifies only "D" for Germany, "D4" for Cape Verde.
# Also some "unusual" callsigns which appear to be in wrong DXCCs will be
# assigned properly this way, for example the Antarctic callsigns.
#
# The return value is an array contains the following elements:
# ("Country Name", "WAZ", "ITU", "Continent",
#   "latitude", "longitude", "UTC difference", "DXCC").
#
###############################################################################

sub DxccGetRecord {
    my $testcall    = $_[0];
    my $matchchars  = 0;
    my $matchprefix = '';
    my $test;
    my $letter = '';
    my @mydxcc = qw/Unknown 0 0 0 0 0 0 ?/;

    # debug
    #print "testcall: $testcall\n";

    if ( not( $testcall =~ /^((\d|[A-Z]|\/)+)$/ ) ) {

        # debug
        #print "callsign not legit\n";
        return @mydxcc;
    }

    if ( $fullcalls{$testcall} ) {    # direct match with a fullcall
            # do nothing! don't try to resolve WPX, it's a full
            # call and will match correctly even if it contains a /
        @mydxcc = @{ $fullcalls{$testcall} };

        # debug
        #print "testcall is a fullcall\n";
        return @mydxcc;
    }

    # rewrite testcall with local rules

    if ( $testcall =~ /(^OH\/)|(\/OH[1-9]?$)/ ) {    # non-Aland prefix!
        $testcall = "OH";    # make callsign OH = finland
    }
    elsif ( $testcall =~ /(^3D2R)|(^3D2.+\/R)/ ) {    # seems to be from Rotuma
        $testcall = "3D2RR";                          # will match with Rotuma
    }
    elsif ( $testcall =~ /^3D2C/ ) {    # seems to be from Conway Reef
        $testcall = "3D2CR";            # will match with Conway
    }
    elsif ( $testcall =~ /(^LZ\/)|(\/LZ[1-9]?$)/ )
    {                                   # LZ/ is LZ0 by DXCC but this is VP8h
        $testcall = "LZ";
    }
    elsif ( $testcall =~ /\w\/\w/ ) {    # check if the callsign has a "/"
        $testcall =
          &DxccWpx($testcall) . "AA";    # use the wpx prefix instead, which may
                                         # intentionally be wrong, see &wpx!
    }

    # debug
    #print "testcall is rewritten as: $testcall\n";

    # pick the top letter
    $letter = substr( $testcall, 0, 1 );

    # Test for all the prefixes
    for my $testprefix ( keys %prefixes ) {
        my $len = length($testprefix);
        if ( $letter ne substr( $testprefix, 0, 1 ) ) {    # gains 20% speed
            next;
        }
        $testprefix =~ /^([A-Z0-9\/]+)/;
        $len = length($1);
        if ( substr( $testcall, 0, $len ) eq substr( $testprefix, 0, $len )
            && ( $matchchars <= $len ) )
        {
            $matchchars  = $len;
            $matchprefix = $testprefix;

            # debug
            #print "matched: $matchprefix length: $matchchars\n";
        }
    }

    if ( exists( $prefixes{$matchprefix} ) ) {
        @mydxcc = @{ $prefixes{$matchprefix} };
    }

 # cty.dat has special entries for WAE countries which are not separate DXCC
 # countries. Those start with a "*", for example *TA1. Those have to be changed
 # to the proper DXCC. Since there are opnly a few of them, it is hardcoded in
 # here.

    if ( $mydxcc[7] =~ /^\*/ ) {    # WAE country!
        if ( $mydxcc[7] eq '*TA1' )  { $mydxcc[7] = "TA" }   # Turkey
        if ( $mydxcc[7] eq '*4U1V' ) { $mydxcc[7] = "OE" }   # 4U1VIC is in OE..
        if ( $mydxcc[7] eq '*GM/s' ) { $mydxcc[7] = "GM" }   # Shetlands
        if ( $mydxcc[7] eq '*IG9' )  { $mydxcc[7] = "I" }    # African Italy
        if ( $mydxcc[7] eq '*IT9' )  { $mydxcc[7] = "I" }    # Sicily
        if ( $mydxcc[7] eq '*JW/b' ) { $mydxcc[7] = "JW" }   # Bear Island
    }

    # include "/" in the Main Prefix

    return @mydxcc;

}    # DxccGetRecord ends here

##############################################################################
#
# DxccReadCty reads and parses the cty.dat, residing in the following
# diretories, searching by the following sequence:
#
# * /usr/share/dxcc/cty.dat
# * /usr/local/share/dxcc/cty.dat
# * <The path where the dxcc script resides>/cty.dat
#
# This sub initializes the two hashes used by &DxccGetRecord:
#
# * %fullcalls, where the keys are the full callsigns (withOUT the first =),
#   and the values are the arrays of DxccGetRecord returning values; and
# * %prefixes, where the keys are the prefixes,
#   and the values are the arrays of DxccGetRecord returning values.
#
##############################################################################

sub DxccReadCty {

    # Read cty.dat from AD1C in
    # /usr/share/dxcc, /usr/local/share/dxcc,
    # and where the script resides.

    my $filename;

    if ( -e "/usr/share/dxcc/cty.dat" ) {
        $filename = "/usr/share/dxcc/cty.dat";
    }
    elsif ( -e "/usr/local/share/dxcc/cty.dat" ) {
        $filename = "/usr/local/share/dxcc/cty.dat";
    }
    elsif ( -e "$scriptdirname/cty.dat" ) {
        $filename = "$scriptdirname/cty.dat";
    }
    else {
        die("Unable to find cty.dat\n");
    }

    open CTY, $filename;

    my @lastdxcc;

    while ( my $line = <CTY> ) {

        if ( substr( $line, 0, 1 ) ne ' ' ) {    # New DXCC
            $line =~ /\s+([*A-Za-z0-9\/]+):\s+$/;
            my $mainprefix = $1;
            $line =~ s/\s{2,}//g;

            # Save the current DXCC entry for the Main Prefix
            @lastdxcc = split( /:/, $line );
        }
        else {                                   # prefix-line
            $line =~ s/\s+//g;

            # split a line into words
            # (fullcalls or prefixes with zone amendment data)
            my @words = split( /,|;/, $line );

            # debug
            #print "prefix-line of mainprefix: $mainprefix\n";

            for my $word (@words) {

                # debug
                #print "word: $word\n";

                # dxccval may be modified
                my @dxccval = @lastdxcc;

                if ( $word =~ /\((\d+)\)/ ) {    # CQ-Zone in ()
                    $dxccval[1] = $1;

                    # debug
                    #print "new cq zone: $dxccval[1]\n";
                }
                if ( $word =~ /\[(\d+)\]/ ) {    # ITU-Zone in []
                    $dxccval[2] = $1;

                    # debug
                    #print "new itu zone: $dxccval[2]\n";
                }
                if ( $word =~ /=?([A-Z0-9\/]+)/ ) {

                    # callsign: fullcall or prefix
                    my $callsign = $1;
                    if ( substr( $word, 0, 1 ) eq '=' ) {

                        # fullcall
                        $fullcalls{$callsign} = [@dxccval];

                        # debug
                        #print "new fullcall $callsign\n elements:";
                        #for my $i ( @{ $fullcalls{$callsign} } ) {
                        #    print " $i, ";
                        #}
                        #print "\n";
                    }
                    else {
                        # "normal" prefix
                        $prefixes{$callsign} = [@dxccval];

                        # debug
                        #print "new prefix $callsign\n elements:";
                        #for my $i ( @{ $prefixes{$callsign} } ) {
                        #    print " $i, ";
                        #}
                        #print "\n";
                    }
                }
            }
        }
    }
    close CTY;

}    # ends DxccReadCty

exit;
